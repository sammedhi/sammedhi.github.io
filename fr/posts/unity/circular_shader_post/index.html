<!DOCTYPE html>
<html lang="fr" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Envelopper le monde avec Unity | L’Exploration Tech d’Impyou</title>
<meta name="keywords" content="">
<meta name="description" content="Dans l&rsquo;article d&rsquo;aujourd&rsquo;hui, nous parlerons d&rsquo;une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d&rsquo;une simple interrogation &ldquo;Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?&rdquo;.
Existe-t-il un moyen de tirer pleinement profit de l&rsquo;environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l&rsquo;impression que l&rsquo;expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l&rsquo;idée 2D du jeu tout en utilisant l&rsquo;aspect 3D de la VR ? Et si on pouvait&hellip; envelopper le monde autour de nous !">
<meta name="author" content="">
<link rel="canonical" href="https://sammedhi.github.io/fr/posts/unity/circular_shader_post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sammedhi.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sammedhi.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sammedhi.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sammedhi.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sammedhi.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://sammedhi.github.io/posts/unity/circular_shader_post/">
<link rel="alternate" hreflang="fr" href="https://sammedhi.github.io/fr/posts/unity/circular_shader_post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['\\(', '\\)']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>


<link rel="stylesheet" href="/css/custom.css"><meta property="og:url" content="https://sammedhi.github.io/fr/posts/unity/circular_shader_post/">
  <meta property="og:site_name" content="L’Exploration Tech d’Impyou">
  <meta property="og:title" content="Envelopper le monde avec Unity">
  <meta property="og:description" content="Dans l’article d’aujourd’hui, nous parlerons d’une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d’une simple interrogation “Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?”.
Existe-t-il un moyen de tirer pleinement profit de l’environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l’impression que l’expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l’idée 2D du jeu tout en utilisant l’aspect 3D de la VR ? Et si on pouvait… envelopper le monde autour de nous !">
  <meta property="og:locale" content="fr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-25T11:22:05+02:00">
    <meta property="article:modified_time" content="2025-07-25T11:22:05+02:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Envelopper le monde avec Unity">
<meta name="twitter:description" content="Dans l&rsquo;article d&rsquo;aujourd&rsquo;hui, nous parlerons d&rsquo;une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d&rsquo;une simple interrogation &ldquo;Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?&rdquo;.
Existe-t-il un moyen de tirer pleinement profit de l&rsquo;environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l&rsquo;impression que l&rsquo;expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l&rsquo;idée 2D du jeu tout en utilisant l&rsquo;aspect 3D de la VR ? Et si on pouvait&hellip; envelopper le monde autour de nous !">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sammedhi.github.io/fr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Envelopper le monde avec Unity",
      "item": "https://sammedhi.github.io/fr/posts/unity/circular_shader_post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Envelopper le monde avec Unity",
  "name": "Envelopper le monde avec Unity",
  "description": "Dans l\u0026rsquo;article d\u0026rsquo;aujourd\u0026rsquo;hui, nous parlerons d\u0026rsquo;une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d\u0026rsquo;une simple interrogation \u0026ldquo;Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?\u0026rdquo;.\nExiste-t-il un moyen de tirer pleinement profit de l\u0026rsquo;environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l\u0026rsquo;impression que l\u0026rsquo;expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l\u0026rsquo;idée 2D du jeu tout en utilisant l\u0026rsquo;aspect 3D de la VR ? Et si on pouvait\u0026hellip; envelopper le monde autour de nous !\n",
  "keywords": [
    
  ],
  "articleBody": "Dans l’article d’aujourd’hui, nous parlerons d’une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d’une simple interrogation “Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?”.\nExiste-t-il un moyen de tirer pleinement profit de l’environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l’impression que l’expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l’idée 2D du jeu tout en utilisant l’aspect 3D de la VR ? Et si on pouvait… envelopper le monde autour de nous !\nC’est ce que nous allons explorer dans cet article. C’est parti!\nMéthodes Parlons des différentes approches possibles, pour l’instant, j’en vois 3.\n1. Créer des assets courbés La première option serait de créer vos assets déjà courbés, cela peut être fait dans Blender lors de la création de l’asset. Cependant, cette idée ne semble pas prometteuse, les inconvénients évidents sont :\nCela prend beaucoup de temps pour créer les assets. Ce sera difficile à maintenir, supposons que l’on souhaite changer la courbure du monde, cela demandera trop d’efforts pour modifier chaque asset. Maintenant, il faudra créer une physique spécial pour notre monde courbé. 2. Transformer la géométrie des assets sur Unity Une autre option serait de courber l’asset avec un script lorsqu’il est ajouté au projet ou à la scène. Honnêtement, ça peut être une bonne idée, mais il faut maintenant implémenter un système de physique, un système d’édition, etc. Ça peut être vraiment difficile à gérer, alors gardons la pour une autre expérience.\nOn peut sûrement faire plus simple…\n3. Je t’invoque “Shader” Et si on le simulait ?!\nJe veux dire, nous sommes développeurs, nous simulons beaucoup de choses, mais pouvons-nous le faire dans ce cas ? La réponse est oui !\nLa solution ici c’est l’outil ultime pour simuler des effets visuels : LES SHADERS. Cette fois, grâce à un shader, nous allons simplement simuler la deformations des objets, ce qui signifie que l’objet existera dans notre monde 2D mais nous le montrerons au joueur comme un monde circulaire l’enveloppant.\nCette solution semble prometteuse, d’abord parce que cela ne devrait pas être trop difficile à faire, mais aussi parce que puisque nous simulons la deformation de notre monde, nous pouvons toujours travailler avec la physique de base d’Unity. De plus, changer les paramètres d’enveloppement devrait être aussi simple que de déplacer un curseur.\nPrincipe Alors, comment pouvons-nous courber nos objets en utilisant des shaders ? Mon idée ici est d’envelopper notre monde 2D autour d’un cercle.\nFaisons d’abord quelques hypothèses pour notre système :\nNotre monde sera construit sur un plan défini par \\(z\\) = une constante, donc il s’étend sur les axes \\(xy\\).\nLa coordonnée \\(y\\) ne sera pas modifiée, donc nous pouvons écrire nos coordonnées comme \\((x, z)\\).\nNous envelopperons notre monde autour d’un cercle avec un centre \\((0, 0)\\) et un rayon \\(z\\).\nL’axe \\(x\\) de notre monde sera limité entre \\([-w, w]\\), \\(w\\) étant la largeur de notre monde. Les points du monde avec \\(x = 0\\) ne seront pas déplacés.\nThéorie Partons de nos hypothèses et parlons des mathématiques derrière tout cela !\nL’idée est de regarder notre monde depuis le haut, appelons-le \\(W\\). En faisant cela, nous pouvons voir que notre monde est une ligne le long de l’axe \\(x\\). Il est éloigné sur l’axe \\(z\\) par une distance que nous noterons \\(z\\). Ici, nous souhaitons envelopper notre monde autour d’un cercle centré en \\((0, 0)\\) avec un rayon \\(z\\).\nDans notre cas, notre monde est tangente à notre cercle. Le but est d’envelopper ce monde autour du cercle, alors plaçons d’abord quelques points de référence. Il n’y a pas de math derrière cela, c’est une décision de design que j’ai prise ici, donc si vous voulez la changer, n’hésitez pas ! Vous devrez simplement adapter vos formules pour qu’elles correspondent à votre design.\nIci, nous devons trouver une fonction pour effectuer une telle transformation. Nous pourrions en trouver plusieurs, mais utilisons la plus simple possible, une fonction linéaire.\nEn pratique, cela signifie que si vous prenez un point entre le début et la fin du monde et mesurez sa position comme un pourcentage de la ligne parcourue, pour créer le point correspondant sur le cercle, il faut prendre le début et la fin du périmètre et placer le point au pourcentage précédemment calculé entre les deux extrémités.\nPuisque nous avons décidé d’utiliser une fonction linéaire, elle prend la forme suivante :\n$$f(x) = ax$$Avec \\(f\\) la fonction qui transforme la position de l’objet sur l’axe \\(x\\) en angle thêta du point dans le monde circulaire.\n$$f(x) = \\theta$$ $$ax = \\theta$$Déterminons \\(a\\), sachant que nous voulons convertir notre espace initial \\([-w, w]\\) en \\([-\\pi, \\pi]\\). D’après notre décision de design, nous savons que :\n$$f(0) = 0$$ $$f(w) = \\pi$$Pour 0, c’est évident \\(a \\cdot 0 = 0\\), cela fonctionnera pour n’importe quel \\(a\\), mais résolvons pour \\(w\\) :\n$$f(w) = \\pi$$ $$a \\cdot w = \\pi$$ $$a = \\frac{\\pi}{w}$$Si nous remplaçons avec \\(-w\\), nous remarquons que cela conduit à la même valeur de \\(a\\).\nMaintenant, nous pouvons réécrire \\(f\\) :\n$$f(x) = \\frac{\\pi}{w} \\cdot x \\tag{1} = \\theta(x)$$Donc, une fois que nous avons l’angle, nous pouvons déterminer la position sur le périmètre du cercle de notre point en utilisant un peu de trigonométrie. Commençons par la fonction pour exprimer les coordonnées \\((x_c, y_c)\\) pour un cercle de rayon \\(r\\) basé sur \\(\\theta\\) :\n$$(x_c, y_c) = (sin(\\theta), cos(\\theta)) \\cdot r \\tag{2}$$En injectant \\((1)\\) dans \\((2)\\), nous obtenons :\n$$(x_c, y_c) = (sin(\\frac{\\pi}{w} \\cdot x), cos(\\frac{\\pi}{w} \\cdot x)) \\cdot r$$Maintenant, nous sommes capables de mapper la position originale \\(x\\) à la position finale \\((x_c, y_c)\\), écrivons le code !\nApplication Ici, faisons le monde le plus simple possible.\nSimple comme on l’aime !\nCommençons par les propriétés de notre shader :\nProperties { _MainTex (\"Texture\", 2D) = \"white\" {} _Tint (\"Tint\", Color) = (1,1,1,1) _GameWidth (\"Game width\", Float) = 1 } Maintenant que nous avons les propriétés, configurons les données d’entrée et de sortie de notre pass et définissons les variables dont nous pourrions avoir besoin.\n// Nous définissons la constante pi #define PI 3.14159265359 // L'entrée de notre vertex shader struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; // Les données passées de notre vertex shader à notre fragment shader struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; // Nous récupérons nos propriétés sampler2D _MainTex; float4 _MainTex_ST; float _GameWidth; float4 _Tint; C’était assez simple, nous obtenons juste le vertex et les uv en entrée, nous pouvons les modifier comme nous voulons et nous les passons au fragment shader.\nÉcrivons d’abord le fragment shader car il sera simple.\nfixed4 frag (v2f i) : SV_Target { // échantillonne la texture fixed4 col = tex2D(_MainTex, i.uv) * _Tint; return col; } Donc, en gros, nous obtenons juste la couleur de notre texture et la mélangeons avec notre teinte et l’appliquons au pixel.\nPassons maintenant à la partie la plus intéressante, nous pouvons écrire notre pass vertex ! Nous avons juste besoin d’écrire la formule que nous avons construite précédemment.\nv2f vert (appdata v) { v2f o; // Calcule la position du vertex dans l'espace monde float4 worldSpaceVertex = mul(unity_ObjectToWorld, v.vertex); // Calcule la position relative du vertex dans la fenêtre de jeu float percent = worldSpaceVertex.x / (_GameWidth / 2); // Calcule l'angle correspondant à la position du vertex float theta = percent * PI ; // Stocke le rayon float radius = worldSpaceVertex.z; // Calcule les coordonnées circulaires float2 circularCoord = float2(sin(theta), cos(theta)) * radius; // Définit la nouvelle coordonnée du vertex dans le monde float4 newWorldVertex = float4(circularCoord.x, worldSpaceVertex.y, circularCoord.y, 1); // Projette le vertex dans l'espace de clipping o.vertex = mul(UNITY_MATRIX_VP, newWorldVertex); // Définit les uv du vertex o.uv = TRANSFORM_TEX(v.uv, _MainTex); // Passe les données au fragment shader return o; } Et cela devrait être bon !\nArf, on ne peut pas appeler cela une courbure, regardons les wireframes des objets.\nC’est logique, nous ne changeons que les positions des vertex, donc si nous avons peu de vertex on ne peux pas vraiment le courber. Ajoutons plus de détails à notre cube.\nVotre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez la télécharger et la voir dans votre lecteur vidéo préféré !\rOk, maintenant nous avons notre cube, courbons-le !\nVotre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez la télécharger et la voir dans votre lecteur vidéo préféré !\rOui, nous sommes m… marche, non ? Quelque chose d’étrange se passe quand je regarde sur le côté.\nLes objets disparaissent, c’est parce qu’Unity va éliminer les objets lorsque leurs bounding boxes n’apparaissent pas à l’écran. Nous avons changé les positions des vertex mais pas les bounding boxes. Heureusement, c’est assez facile à faire, mais cette fois, nous devons écrire un script en C#.\nusing UnityEngine; [ExecuteAlways, RequireComponent(typeof(Renderer))] public class BoundingBoxUpdater : MonoBehaviour { void Awake() { var renderer = GetComponent(); // S'il n'y a pas de matériau ou s'il n'utilise pas notre shader var mat = renderer.sharedMaterial; if (mat == null || mat.shader.name != \"Unlit/WrapShader\") return; // Nous rendons les bounds énormes ! renderer.bounds = new Bounds(Vector3.zero, Vector3.one * 1000); } } Ok, est-ce que ça marche maintenant ?\nVotre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez la télécharger et la voir dans votre lecteur vidéo préféré !\rOui, cette fois, nous l’avons ! Soyez juste prudent avec cette solution pour changer la bounding box. Ici, nous la rendons juste énorme pour qu’elle puisse être dessinée de n’importe où, mais cela a des implications sur les performances. Mon conseil serait de calculer correctement les bounding boxes en fonction des nouvelles positions des bords de la forme cible.\nDernière chose, mettons à jour ce shader pour qu’il fonctionne en VR !\nstruct appdata { ... UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { ... UNITY_VERTEX_OUTPUT_STEREO }; v2f vert (appdata v) { v2f o; UNITY_SETUP_INSTANCE_ID(v); //Insert UNITY_INITIALIZE_OUTPUT(v2f, o); //Insert UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); //Insert ... } Pour un petit test en VR, j’ai configuré une scène très simple avec un personnage qui peut bouger et sauter.\nVotre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez la télécharger et la voir dans votre lecteur vidéo préféré !\rComme nous pouvons le voir, nous pouvons passer de notre plateformer 2D à un plateformer circulaire ! Et la physique fonctionnent comme prévu parce qu’en réalité, nous jouons toujours à un jeu 2D.\nSoyons juste prudents puisque nos objets peuvent sortir de l’écran, nous pouvons toujours les voir car notre formule suit un pattern sinusoïdal.\nCependant, les objets seront physiquement hors de la scène. Pour aller plus loin, nous pourrions implémenter un défilement dans notre monde ou réinitialiser la position du personnage lorsque nous atteignons la limite, tout cela dépend de votre jeu !\nConclusion La solution est assez satisfaisante, mais il y a quelques points à prendre en compte :\nD’abord, la solution a un coût de calcul puisqu’on repositionne chaque vertex à chaque frame. Même si cela devrait être supportable, il faut le prendre en compte et il faudrait l’évaluer correctement.\nLes objets peuvent être déformés en fonction du rapport cercle / monde, donc vous devez être prudent dans sa configuration et bien réfléchir à la façon dont vous concevez vos assets. Il pourrait aussi être possible de choisir une formule de projection différente pour atténuer ces effets.\nVous pourriez avoir besoin d’écrire quelques outils pour aider votre designer à travailler dans ce nouvel environnement.\nCependant, je pense qu’il y a des tonnes de possibilités et je crois que cela peut rendre les jeux VR vraiment fun, j’adorerais voir un jeu utilisant ce principe en VR !\nJe pourrais essayer d’expérimenter davantage et peut-être faire quelque chose de jouable, dites-moi ce que vous en pensez.\nAussi, voici le code pour ceux qui veulent jouer avec : ici\n",
  "wordCount" : "2021",
  "inLanguage": "fr",
  "datePublished": "2025-07-25T11:22:05+02:00",
  "dateModified": "2025-07-25T11:22:05+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sammedhi.github.io/fr/posts/unity/circular_shader_post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "L’Exploration Tech d’Impyou",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sammedhi.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sammedhi.github.io/fr/" accesskey="h" title="L’Exploration Tech d’Impyou (Alt + H)">L’Exploration Tech d’Impyou</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://sammedhi.github.io/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sammedhi.github.io/fr/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://sammedhi.github.io/fr/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Envelopper le monde avec Unity
    </h1>
    <div class="post-meta"><span title='2025-07-25 11:22:05 +0200 CEST'>juillet 25, 2025</span>&nbsp;|&nbsp;Traductions:
<ul class="i18n_list">
    <li>
        <a href="https://sammedhi.github.io/posts/unity/circular_shader_post/">En</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><p>Dans l&rsquo;article d&rsquo;aujourd&rsquo;hui, nous parlerons d&rsquo;une expérience que je voulais mener pour rendre les jeux de type plateformers 2D plus intéressants en VR. Tout est parti d&rsquo;une simple interrogation <em>&ldquo;Peux t-on rendre les platformers 2D plus cool à jouer dans un monde immersif ?&rdquo;</em>.</p>
<p>Existe-t-il un moyen de tirer pleinement profit de l&rsquo;environnement à 360° ? On pourrait simplement faire défiler le monde, ce serait intéressant à experimenter mais cela ne donne pas l&rsquo;impression que l&rsquo;expérience serait tellement améliorée en VR par rapport à un écran. Alors, comment pourrions-nous garder l&rsquo;idée 2D du jeu tout en utilisant l&rsquo;aspect 3D de la VR ? Et si on pouvait&hellip; <strong>envelopper le monde autour de nous !</strong></p>
<p>C&rsquo;est ce que nous allons explorer dans cet article. C&rsquo;est parti!</p>
<h2 id="méthodes">Méthodes<a hidden class="anchor" aria-hidden="true" href="#méthodes">#</a></h2>
<p>Parlons des différentes approches possibles, <em>pour l&rsquo;instant, j&rsquo;en vois 3</em>.</p>
<h3 id="1-créer-des-assets-courbés">1. <em>Créer des assets courbés</em><a hidden class="anchor" aria-hidden="true" href="#1-créer-des-assets-courbés">#</a></h3>
<p>La première option serait de créer vos assets déjà courbés, cela peut être fait dans Blender lors de la création de l&rsquo;asset. Cependant, cette idée ne semble pas prometteuse, les inconvénients évidents sont :</p>
<ul>
<li>Cela prend beaucoup de temps pour créer les assets.</li>
<li>Ce sera difficile à maintenir, supposons que l&rsquo;on souhaite changer la courbure du monde, cela demandera trop d&rsquo;efforts pour modifier chaque asset.</li>
<li>Maintenant, il faudra créer une physique spécial pour notre monde courbé.</li>
</ul>


<figure class="center"><img loading="lazy" src="/posts/unity/circular_shader_post/images/ew-disgust.gif"
         alt="ewwww"/> 
</figure>

<h3 id="2-transformer-la-géométrie-des-assets-sur-unity">2. <em>Transformer la géométrie des assets sur Unity</em><a hidden class="anchor" aria-hidden="true" href="#2-transformer-la-géométrie-des-assets-sur-unity">#</a></h3>
<p>Une autre option serait de courber l&rsquo;asset avec un script lorsqu&rsquo;il est ajouté au projet ou à la scène. Honnêtement, ça peut être une bonne idée, mais il faut maintenant implémenter un système de physique, un système d&rsquo;édition, etc. Ça peut être vraiment difficile à gérer, alors gardons la pour une autre expérience.</p>
<p>On peut sûrement faire plus simple&hellip;</p>
<h3 id="3-je-t">3. <em>Je t&rsquo;invoque &ldquo;Shader&rdquo;</em><a hidden class="anchor" aria-hidden="true" href="#3-je-t">#</a></h3>
<p>Et si on le simulait ?!</p>
<p>Je veux dire, nous sommes développeurs, nous simulons beaucoup de choses, mais pouvons-nous le faire dans ce cas ? La réponse est oui !<br>
La solution ici c&rsquo;est l&rsquo;outil ultime pour simuler des effets visuels : <em>LES SHADERS</em>. Cette fois, grâce à un shader, nous allons simplement simuler la deformations des objets, ce qui signifie que l&rsquo;objet existera dans notre monde 2D mais nous le montrerons au joueur comme un monde circulaire l&rsquo;enveloppant.</p>
<p>Cette solution semble prometteuse, d&rsquo;abord parce que cela ne devrait pas être trop difficile à faire, mais aussi parce que puisque nous simulons la deformation de notre monde, nous pouvons toujours travailler avec la physique de base d&rsquo;Unity. De plus, changer les paramètres d&rsquo;enveloppement devrait être aussi simple que de déplacer un curseur.</p>
<h2 id="principe">Principe<a hidden class="anchor" aria-hidden="true" href="#principe">#</a></h2>
<p>Alors, comment pouvons-nous courber nos objets en utilisant des shaders ? Mon idée ici est d&rsquo;envelopper notre monde 2D autour d&rsquo;un cercle.</p>
<p>Faisons d&rsquo;abord quelques hypothèses pour notre système :</p>
<ul>
<li>
<p>Notre monde sera construit sur un plan défini par \(z\) = une constante, donc il s&rsquo;étend sur les axes \(xy\).</p>
</li>
<li>
<p>La coordonnée \(y\) ne sera pas modifiée, donc nous pouvons écrire nos coordonnées comme \((x, z)\).</p>
</li>
<li>
<p>Nous envelopperons notre monde autour d&rsquo;un cercle avec un centre \((0, 0)\) et un rayon \(z\).</p>
</li>
<li>
<p>L&rsquo;axe \(x\) de notre monde sera limité entre \([-w, w]\), \(w\) étant la largeur de notre monde. Les points du monde avec \(x = 0\) ne seront pas déplacés.</p>
</li>
</ul>
<h3 id="théorie">Théorie<a hidden class="anchor" aria-hidden="true" href="#théorie">#</a></h3>
<p>Partons de nos hypothèses et parlons des mathématiques derrière tout cela !</p>
<p>L&rsquo;idée est de regarder notre monde depuis le haut, appelons-le \(W\). En faisant cela, nous pouvons voir que notre monde est une ligne le long de l&rsquo;axe \(x\). Il est éloigné sur l&rsquo;axe \(z\) par une distance que nous noterons \(z\). Ici, nous souhaitons envelopper notre monde autour d&rsquo;un cercle centré en \((0, 0)\) avec un rayon \(z\).</p>
<p><img alt="ProblemConstruction" loading="lazy" src="/posts/unity/circular_shader_post/images/ProblemConstruction.gif"></p>
<p>Dans notre cas, notre monde est tangente à notre cercle. Le but est d&rsquo;envelopper ce monde autour du cercle, alors plaçons d&rsquo;abord quelques points de référence. Il n&rsquo;y a pas de math derrière cela, c&rsquo;est une décision de design que j&rsquo;ai prise ici, donc si vous voulez la changer, n&rsquo;hésitez pas ! Vous devrez simplement adapter vos formules pour qu&rsquo;elles correspondent à votre design.</p>
<p><img alt="ExplainPointProjection" loading="lazy" src="/posts/unity/circular_shader_post/images/ExplainPointProjection.gif"></p>
<p>Ici, nous devons trouver une fonction pour effectuer une telle transformation. Nous pourrions en trouver plusieurs, mais utilisons la plus simple possible, une fonction linéaire.<br>
En pratique, cela signifie que si vous prenez un point entre le début et la fin du monde et mesurez sa position comme un pourcentage de la ligne parcourue, pour créer le point correspondant sur le cercle, il faut prendre le début et la fin du périmètre et placer le point au pourcentage précédemment calculé entre les deux extrémités.</p>
<p><img alt="ShowMapCircleRelationship" loading="lazy" src="/posts/unity/circular_shader_post/images/ShowMapCircleRelationship.gif"></p>
<p>Puisque nous avons décidé d&rsquo;utiliser une fonction linéaire, elle prend la forme suivante :</p>
$$f(x) = ax$$<p>Avec \(f\) la fonction qui transforme la position de l&rsquo;objet sur l&rsquo;axe \(x\) en angle thêta du point dans le monde circulaire.</p>
$$f(x) = \theta$$<p>
</p>
$$ax = \theta$$<p>Déterminons \(a\), sachant que nous voulons convertir notre espace initial \([-w, w]\) en \([-\pi, \pi]\). D&rsquo;après notre décision de design, nous savons que :</p>
$$f(0) = 0$$<p>
</p>
$$f(w) = \pi$$<p>Pour 0, c&rsquo;est évident \(a \cdot 0 = 0\), cela fonctionnera pour n&rsquo;importe quel \(a\), mais résolvons pour \(w\) :</p>
$$f(w) = \pi$$<p>
</p>
$$a \cdot w = \pi$$<p>
</p>
$$a = \frac{\pi}{w}$$<p>Si nous remplaçons avec \(-w\), nous remarquons que cela conduit à la même valeur de \(a\).</p>
<p>Maintenant, nous pouvons réécrire \(f\) :</p>
$$f(x) = \frac{\pi}{w} \cdot x \tag{1} = \theta(x)$$<p>Donc, une fois que nous avons l&rsquo;angle, nous pouvons déterminer la position sur le périmètre du cercle de notre point en utilisant un peu de trigonométrie. Commençons par la fonction pour exprimer les coordonnées \((x_c, y_c)\) pour un cercle de rayon \(r\) basé sur \(\theta\) :</p>
$$(x_c, y_c) = (sin(\theta), cos(\theta)) \cdot r \tag{2}$$<p>En injectant \((1)\) dans \((2)\), nous obtenons :</p>
$$(x_c, y_c) = (sin(\frac{\pi}{w} \cdot x), cos(\frac{\pi}{w} \cdot x)) \cdot r$$<p>Maintenant, nous sommes capables de mapper la position originale \(x\) à la position finale \((x_c, y_c)\), écrivons le code !</p>
<h2 id="application">Application<a hidden class="anchor" aria-hidden="true" href="#application">#</a></h2>
<p>Ici, faisons le monde le plus simple possible.</p>
<p><img alt="2Dworld" loading="lazy" src="/posts/unity/circular_shader_post/images/bare.png"></p>
<p>Simple comme on l&rsquo;aime !</p>
<p>Commençons par les propriétés de notre shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>Properties
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _MainTex (<span style="color:#e6db74">&#34;Texture&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    _Tint (<span style="color:#e6db74">&#34;Tint&#34;</span>, Color) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    _GameWidth (<span style="color:#e6db74">&#34;Game width&#34;</span>, Float) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Maintenant que nous avons les propriétés, configurons les données d&rsquo;entrée et de sortie de notre pass et définissons les variables dont nous pourrions avoir besoin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#75715e">// Nous définissons la constante pi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PI 3.14159265359</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// L&#39;entrée de notre vertex shader</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> appdata
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> POSITION;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Les données passées de notre vertex shader à notre fragment shader</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> v2f
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> SV_POSITION;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Nous récupérons nos propriétés</span>
</span></span><span style="display:flex;"><span>sampler2D _MainTex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> _MainTex_ST;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> _GameWidth;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> _Tint;
</span></span></code></pre></div><p>C&rsquo;était assez simple, nous obtenons juste le vertex et les uv en entrée, nous pouvons les modifier comme nous voulons et nous les passons au fragment shader.</p>
<p>Écrivons d&rsquo;abord le fragment shader car il sera simple.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>fixed4 frag (v2f i) <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_Target</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// échantillonne la texture</span>
</span></span><span style="display:flex;"><span>    fixed4 col <span style="color:#f92672">=</span> tex2D(_MainTex, i.uv) <span style="color:#f92672">*</span> _Tint;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> col;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Donc, en gros, nous obtenons juste la couleur de notre texture et la mélangeons avec notre teinte et l&rsquo;appliquons au pixel.</p>
<p>Passons maintenant à la partie la plus intéressante, nous pouvons écrire notre pass vertex ! Nous avons juste besoin d&rsquo;écrire la formule que nous avons construite précédemment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>v2f vert (appdata v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calcule la position du vertex dans l&#39;espace monde</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> worldSpaceVertex <span style="color:#f92672">=</span> mul(unity_ObjectToWorld, v.vertex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calcule la position relative du vertex dans la fenêtre de jeu</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> percent <span style="color:#f92672">=</span> worldSpaceVertex.x <span style="color:#f92672">/</span> (_GameWidth <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calcule l&#39;angle correspondant à la position du vertex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> theta <span style="color:#f92672">=</span> percent <span style="color:#f92672">*</span> PI ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Stocke le rayon</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius <span style="color:#f92672">=</span> worldSpaceVertex.z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calcule les coordonnées circulaires</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> circularCoord <span style="color:#f92672">=</span> <span style="color:#66d9ef">float2</span>(sin(theta), cos(theta)) <span style="color:#f92672">*</span> radius;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Définit la nouvelle coordonnée du vertex dans le monde</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> newWorldVertex <span style="color:#f92672">=</span> <span style="color:#66d9ef">float4</span>(circularCoord.x, worldSpaceVertex.y, circularCoord.y, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Projette le vertex dans l&#39;espace de clipping</span>
</span></span><span style="display:flex;"><span>    o.vertex <span style="color:#f92672">=</span> mul(UNITY_MATRIX_VP, newWorldVertex);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Définit les uv du vertex</span>
</span></span><span style="display:flex;"><span>    o.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(v.uv, _MainTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Passe les données au fragment shader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Et cela devrait être bon !</p>
<p><img alt="Wtf" loading="lazy" src="/posts/unity/circular_shader_post/images/notbending.png"></p>
<p>Arf, on ne peut pas appeler cela une courbure, regardons les wireframes des objets.</p>
<p><img alt="WireframeWorld" loading="lazy" src="/posts/unity/circular_shader_post/images/notbendingwireframe.png"></p>
<p>C&rsquo;est logique, nous ne changeons que les positions des vertex, donc si nous avons peu de vertex on ne peux pas vraiment le courber. Ajoutons plus de détails à notre cube.</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/make_cube.mp4" type="video/mp4">
  <span>Votre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez <a href="/posts/unity/circular_shader_post/videos/make_cube.mp4">la télécharger</a> et la voir dans votre lecteur vidéo préféré !</span>
</video>
<p>Ok, maintenant nous avons notre cube, courbons-le !</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/bug.mp4" type="video/mp4">
  <span>Votre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez <a href="/posts/unity/circular_shader_post/videos/bug.mp4">la télécharger</a> et la voir dans votre lecteur vidéo préféré !</span>
</video>
<p>Oui, nous sommes m&hellip; marche, non ? Quelque chose d&rsquo;étrange se passe quand je regarde sur le côté.</p>
<p>Les objets disparaissent, c&rsquo;est parce qu&rsquo;Unity va éliminer les objets lorsque leurs <a href="https://docs.unity3d.com/ScriptReference/Renderer-bounds.html">bounding boxes</a> n&rsquo;apparaissent pas à l&rsquo;écran. Nous avons changé les positions des vertex mais pas les bounding boxes. Heureusement, c&rsquo;est assez facile à faire, mais cette fois, nous devons écrire un script en C#.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[ExecuteAlways, RequireComponent(typeof(Renderer))]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoundingBoxUpdater</span> : MonoBehaviour
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> Awake()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> renderer = GetComponent&lt;Renderer&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// S&#39;il n&#39;y a pas de matériau ou s&#39;il n&#39;utilise pas notre shader</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> mat = renderer.sharedMaterial;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mat == <span style="color:#66d9ef">null</span> || mat.shader.name != <span style="color:#e6db74">&#34;Unlit/WrapShader&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Nous rendons les bounds énormes !</span>
</span></span><span style="display:flex;"><span>        renderer.bounds = <span style="color:#66d9ef">new</span> Bounds(Vector3.zero, Vector3.one * <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ok, est-ce que ça marche maintenant ?</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/working.mp4" type="video/mp4">
  <span>Votre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez <a href="/posts/unity/circular_shader_post/videos/working.mp4">la télécharger</a> et la voir dans votre lecteur vidéo préféré !</span>
</video>
<p>Oui, cette fois, nous l&rsquo;avons ! Soyez juste prudent avec cette solution pour changer la bounding box. Ici, nous la rendons juste énorme pour qu&rsquo;elle puisse être dessinée de n&rsquo;importe où, mais cela a des implications sur les performances. Mon conseil serait de calculer correctement les bounding boxes en fonction des nouvelles positions des bords de la forme cible.</p>
<p>Dernière chose, mettons à jour ce shader pour qu&rsquo;il fonctionne en VR !</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> appdata
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> v2f
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    UNITY_VERTEX_OUTPUT_STEREO
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>v2f vert (appdata v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    UNITY_SETUP_INSTANCE_ID(v); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>    UNITY_INITIALIZE_OUTPUT(v2f, o); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Pour un petit test en VR, j&rsquo;ai configuré une scène très simple avec un personnage qui peut bouger et sauter.</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/demo.mp4" type="video/mp4">
  <span>Votre navigateur ne permet pas l'intégration de vidéos, mais ce n'est pas grave ; vous pouvez <a href="/posts/unity/circular_shader_post/videos/demo.mp4">la télécharger</a> et la voir dans votre lecteur vidéo préféré !</span>
</video>
<p>Comme nous pouvons le voir, nous pouvons passer de notre plateformer 2D à un plateformer circulaire ! Et la physique fonctionnent comme prévu parce qu&rsquo;en réalité, nous jouons toujours à un jeu 2D.</p>
<p>Soyons juste prudents puisque nos objets peuvent sortir de l&rsquo;écran, nous pouvons toujours les voir car notre formule suit un pattern sinusoïdal.<br>
Cependant, les objets seront physiquement hors de la scène. Pour aller plus loin, nous pourrions implémenter un défilement dans notre monde ou réinitialiser la position du personnage lorsque nous atteignons la limite, tout cela dépend de votre jeu !</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>La solution est assez satisfaisante, mais il y a quelques points à prendre en compte :</p>
<ul>
<li>
<p>D&rsquo;abord, la solution a un coût de calcul puisqu&rsquo;on repositionne chaque vertex à chaque frame. Même si cela devrait être supportable, il faut le prendre en compte et il faudrait l&rsquo;évaluer correctement.</p>
</li>
<li>
<p>Les objets peuvent être déformés en fonction du rapport cercle / monde, donc vous devez être prudent dans sa configuration et bien réfléchir à la façon dont vous concevez vos assets. Il pourrait aussi être possible de choisir une formule de projection différente pour atténuer ces effets.</p>
</li>
<li>
<p>Vous pourriez avoir besoin d&rsquo;écrire quelques outils pour aider votre designer à travailler dans ce nouvel environnement.</p>
</li>
</ul>
<p>Cependant, je pense qu&rsquo;il y a des tonnes de possibilités et je crois que cela peut rendre les jeux VR vraiment fun, j&rsquo;adorerais voir un jeu utilisant ce principe en VR !<br>
Je pourrais essayer d&rsquo;expérimenter davantage et peut-être faire quelque chose de jouable, dites-moi ce que vous en pensez.</p>
<p>Aussi, voici le code pour ceux qui veulent jouer avec : <a href="https://github.com/sammedhi/WrapShader">ici</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://sammedhi.github.io/fr/">L’Exploration Tech d’Impyou</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
