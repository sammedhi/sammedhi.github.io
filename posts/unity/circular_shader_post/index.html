<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Wrapping the world | Impyou&#39;s voyage</title>
<meta name="keywords" content="">
<meta name="description" content="In today&rsquo;s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation &ldquo;2D Plateformer are cool, but can it be cooler to play them in an immersive world ?&rdquo;.
Is there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn&rsquo;t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could &hellip; wrap the world around us !">
<meta name="author" content="">
<link rel="canonical" href="https://sammedhi.github.io/posts/unity/circular_shader_post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sammedhi.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sammedhi.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sammedhi.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sammedhi.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sammedhi.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://sammedhi.github.io/posts/unity/circular_shader_post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['\\(', '\\)']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>


<link rel="stylesheet" href="/css/custom.css"><meta property="og:url" content="https://sammedhi.github.io/posts/unity/circular_shader_post/">
  <meta property="og:site_name" content="Impyou&#39;s voyage">
  <meta property="og:title" content="Wrapping the world">
  <meta property="og:description" content="In today’s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation “2D Plateformer are cool, but can it be cooler to play them in an immersive world ?”.
Is there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn’t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could … wrap the world around us !">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-25T11:22:05+02:00">
    <meta property="article:modified_time" content="2025-07-25T11:22:05+02:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wrapping the world">
<meta name="twitter:description" content="In today&rsquo;s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation &ldquo;2D Plateformer are cool, but can it be cooler to play them in an immersive world ?&rdquo;.
Is there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn&rsquo;t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could &hellip; wrap the world around us !">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sammedhi.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Wrapping the world",
      "item": "https://sammedhi.github.io/posts/unity/circular_shader_post/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Wrapping the world",
  "name": "Wrapping the world",
  "description": "In today\u0026rsquo;s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation \u0026ldquo;2D Plateformer are cool, but can it be cooler to play them in an immersive world ?\u0026rdquo;.\nIs there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn\u0026rsquo;t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could \u0026hellip; wrap the world around us !\n",
  "keywords": [
    
  ],
  "articleBody": "In today’s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation “2D Plateformer are cool, but can it be cooler to play them in an immersive world ?”.\nIs there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn’t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could … wrap the world around us !\nThis is what we will explore in this article. Let’s get right into it !\nMethods Let’s talk about the different ways we could approach this, right now I can think of 3.\n1. Make curved assets So the first option would be to make your assets already curved, it can be done in blender when you create your asset, however this idea doesn’t seem promising, the obvious drawbacks are :\nIt take a long time to make assets. It will be hard to maintain, let’s suppose you want to change the curve of the world it will require too much effort to change every assets. Now you need to create a special physics system for your curved world. 2. Transform geometry when building Another option would be to curve the asset with some script when it’s added to the project or to the scene, honestly it can be a good idea however you now have to implement your own physics system, editor system etc … It can be really hard to manage, so maybe let’s keep it for another experiment.\nWe probably can do simpler …\n3. I summon you “Shader” What about faking it ?!\nI mean we’re developer, we fake a ton of things but can we in this case ? Yes we can ! And the solution is the ultimate tool at faking visual effects SHADER. This time thanks to shaders we’ll just fake the drawing of objects meaning that the object will exist in our 2D map but we will show it to the player as some circular world enveloping him.\nThis solution seems promising, firstly because it’s should not be that hard to make, but also because since we fake the drawing of our world we can still work with the basics physics of unity, additionally changing the wrapping parameters should be as easy as moving a slider.\nPrinciple So how can we bend our object using shader, my idea here is to wrap our 2D map onto a circle.\nLet’s first make some assumption for our system:\nOur world will be build on a plane defined by \\(z\\) = some constant, so it spans the \\(xy\\) axis.\nThe \\(y\\) coordinate will be left untouched, so we can write our coords as \\((x, z)\\).\nWe will wrap our map around a circle with center \\((0, 0)\\) and radius \\(z\\)\nOur map \\(x\\) axis will be bound between \\([-w, w]\\), \\(w\\) being our map width. The map points with \\(x = 0\\) won’t be moved.\nTheory So from our assumptions let’s speak about the math behind it !\nThe idea is to look at our map from the top, let’s call it \\(W\\), doing so we can see that our world is a line along the \\(x\\) axis. It is away on the \\(z\\)-axis by a distance that we will denote \\(z\\). Here we wish to wrap our map around a circle centered at \\((0, 0)\\) with a radius \\(z\\).\nIn our case our map is tangent to our circle. The goal is to wrap the world around the cirle so let’s first put some reference points. There is no math behind this, this is a design decision I made here so if you want to change it feel free to, you only will need to adapt your formulas to fit your design.\nHere we need to find a function to perform such a transformation. We could find many, but let’s use the simplest one possible, a linear function. So in practice that means that if you take a point in between the start and the end of the world and measure its position as percentage of the line crossed, to create the matching point on the circle you would take the start and end of the perimeter and put the point at the previously computed percentage in between both ends.\nSince we decided to use a linear function it takes the following form\n$$f(x) = ax$$With \\(f\\) the function which transform the object position on the \\(x\\) axis to the angle theta of the point in the circular map.\n$$f(x) = \\theta$$ $$ax = \\theta$$Let’s determine \\(a\\), knowing we want to convert our initial space \\([-w, w]\\) to \\([-\\pi, \\pi]\\). From our design decision we know the following\n$$f(0) = 0$$ $$f(w) = \\pi$$For 0 this is obvious \\(a \\cdot 0 = 0\\) it will work for any \\(a\\), but let’s resolve for \\(w\\)\n$$f(w) = \\pi$$ $$a \\cdot w = \\pi$$ $$a = \\frac{\\pi}{w}$$If we plug \\(-w\\) we notice that it lead to the same value of \\(a\\).\nNow we can rewrite \\(f\\)\n$$f(x) = \\frac{\\pi}{w} \\cdot x \\tag{1}$$So once we have the angle we can determine the position in the circle perimeter of our point using some trigonometry, first let’s start from the function to express the coordinates \\((xc, yc)\\) for a circle of radius \\(r\\) based on \\(\\theta\\)\n$$(x_c, y_c) = (sin(\\theta), cos(\\theta)) \\cdot r \\tag{2}$$Injecting \\((1)\\) into \\((2)\\) we got:\n$$(x_c, y_c) = (sin(\\frac{\\pi}{w} \\cdot x), cos(\\frac{\\pi}{w} \\cdot x)) \\cdot r$$Now we are able to map the original position \\(x\\) to the final one \\((x_c, y_c)\\), let’s write the code !\nApplication So here let’s do the simplest map possible\nYeah this is bare !\nLet’s write our shader, first the properties.\nProperties { _MainTex (\"Texture\", 2D) = \"white\" {} _Tint (\"Tint\", Color) = (1,1,1,1) _GameWidth (\"Game width\", Float) = 1 } Now that we have the properties let’s setup the input data and output data of our pass and define the variable we might need.\n// We define the constant pi #define PI 3.14159265359 // The input of our vertex shader struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; // The data passed from our vertex shader to our fragment shader struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; // We fetch our properties sampler2D _MainTex; float4 _MainTex_ST; float _GameWidth; float4 _Tint; It was quite simple, we just get the vertex and uv as inputs, we can modify them however we want and we pass them to the fragment shader.\nLet’s first write the fragment shader since it will be simple\nfixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv) * _Tint; return col; } So basically we just get the color from our texture and mix it with our tint and apply it to the pixel.\nSo for our most interesting part, we can write our vertex pass ! We just need to write down the formula that we built previously.\nv2f vert (appdata v) { v2f o; // Compute the position of the vertex in the world space float4 worldSpaceVertex = mul(unity_ObjectToWorld, v.vertex); // Compute the relative position of the vertex in the game window float percent = worldSpaceVertex.x / (_GameWidth / 2); // Compute the matching angle associated to the vertex position float theta = percent * PI ; // Store the radius float radius = worldSpaceVertex.z; // Compute the circular coordinate float2 circularCoord = float2(sin(theta), cos(theta)) * radius; // Set the new vertex coordinate float4 newWorldVertex = float4(circularCoord.x, worldSpaceVertex.y, circularCoord.y, 1); // Project the vertex to the clip space o.vertex = mul(UNITY_MATRIX_VP, newWorldVertex); // Set the uv of the vertex o.uv = TRANSFORM_TEX(v.uv, _MainTex); // Pass the data to the fragment shader return o; } And that should be it !\nArf we could not call that bending, let’s look at the objects wireframes\nIt make sense we only change the positions of the vertex so if you only have that little vertex you cannot really bend it. Let’s add more details to our cube.\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!\rOk now have our cube, let’s bend it !\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!\rYes we’re g… good, are we ? Something strange is happening when I’m looking on the side\nThe objects disappear, that’s because Unity will cull objects when their bounding boxes don’t appear in screens, we did change the vertex positions but not the bounding boxes. Luckily it’s quite easy to do it, but this time we need to write some C# scripts.\npublic class BoundingBoxUpdater : MonoBehaviour { // Start is called before the first frame update private Material mat; void Start() { // Check if the object got a renderer and a material, if not we exit var renderer = GetComponent(); if (renderer == null) return; var mat = renderer.sharedMaterial; if (mat == null) return; // Check that the material is our wrap shader if (mat.shader.name != \"Unlit/WrapShader\") return; // Update the render box by making it huge renderer.bounds = new Bounds(newCenter, Vector3.one * 1000); } } Ok, Does it work now ?\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!\rYes, this time we got it ! Just be careful about this solution to change the bounding box. Here we just make it huge so it can be drawn from anywhere but it have performance implications, my advice would be to properly compute bounding boxes based on the new edges positions of the target shape.\nOk last things let’s update this shader so it works in VR !\nstruct appdata { ... UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { ... UNITY_VERTEX_OUTPUT_STEREO }; v2f vert (appdata v) { v2f o; UNITY_SETUP_INSTANCE_ID(v); //Insert UNITY_INITIALIZE_OUTPUT(v2f, o); //Insert UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); //Insert ... } So for a little VR test, I setup a stupidly simple scene with a character than can move and jump\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!\rAs we can see we can start from our 2D plateformer to a circular plateformer ! And the physics work as intended because in reality we’re still playing a 2D game.\nJust let’s be careful since our objects can go out of screen we can still see them since our formula follow a sinusoidal pattern. However the objects will physically be out of the scene, to go further we could either implement some scrolling in our world, or reset the position of the character when we reach the limit, all this is up to your game !\nConclusion The solution is quite satisfying however there are some concerns to take into account\nFirst the solution have a computation cost since you will remap each vertex each frame, even though it should be bearable it still need to be taken into account and it should be properly benchmarked.\nObjects can get deformed based on the circle / world map ratio so you need to careful set it up and thoroughly think about the way you design your assets, it might also be possible to pick a different projection formula to mitigate these effects.\nYou might need to write some tooling to help your designer work in this new environment.\nHowever I think there are a ton of possibilites and I believe it can make VR game damn fun, I’d love to see some game using this principle in VR ! I might try to experiment more with it and maybe make something playable, tell me what you think about it.\nAlso here the source for anyone who desire to play with it here\n",
  "wordCount" : "2025",
  "inLanguage": "en",
  "datePublished": "2025-07-25T11:22:05+02:00",
  "dateModified": "2025-07-25T11:22:05+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sammedhi.github.io/posts/unity/circular_shader_post/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Impyou's voyage",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sammedhi.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sammedhi.github.io/" accesskey="h" title="Impyou&#39;s voyage (Alt + H)">Impyou&#39;s voyage</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Wrapping the world
    </h1>
    <div class="post-meta"><span title='2025-07-25 11:22:05 +0200 CEST'>July 25, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>In today&rsquo;s article we will speak about an experiment I wanted to lead to make plateformer more interesting in VR. It started from a simple interrogation <em>&ldquo;2D Plateformer are cool, but can it be cooler to play them in an immersive world ?&rdquo;</em>.<br>
Is there a way to get full profit of the 360 environment ? We could just perfom some plane scrolling, it could be interesting but in VR it doesn&rsquo;t feel like the experience would be improved that much over a flat screen. So how could we still keep the 2D idea of the game yet use the 3D aspect of VR, what if we could &hellip; <strong>wrap the world around us !</strong></p>
<p>This is what we will explore in this article. Let&rsquo;s get right into it !</p>
<h2 id="methods">Methods<a hidden class="anchor" aria-hidden="true" href="#methods">#</a></h2>
<p>Let&rsquo;s talk about the different ways we could approach this, <em>right now I can think of 3</em>.</p>
<h3 id="1-make-curved-assets">1. <em>Make curved assets</em><a hidden class="anchor" aria-hidden="true" href="#1-make-curved-assets">#</a></h3>
<p>So the first option would be to make your assets already curved, it can be done in blender when you create your asset, however this idea doesn&rsquo;t seem promising, the obvious drawbacks are :</p>
<ul>
<li>It take a long time to make assets.</li>
<li>It will be hard to maintain, let&rsquo;s suppose you want to change the curve of the world it will require too much effort to change every assets.</li>
<li>Now you need to create a special physics system for your curved world.</li>
</ul>
<figure class="center">
    <img loading="lazy" src="images/ew-disgust.gif"
         alt="ewwww"/> 
</figure>

<h3 id="2-transform-geometry-when-building">2. <em>Transform geometry when building</em><a hidden class="anchor" aria-hidden="true" href="#2-transform-geometry-when-building">#</a></h3>
<p>Another option would be to curve the asset with some script when it&rsquo;s added to the project or to the scene, honestly it can be a good idea however you now have to implement your own physics system, editor system etc &hellip; It can be really hard to manage, so maybe let&rsquo;s keep it for another experiment.</p>
<p>We probably can do simpler &hellip;</p>
<h3 id="3-i-summon-you">3. <em>I summon you &ldquo;Shader&rdquo;</em><a hidden class="anchor" aria-hidden="true" href="#3-i-summon-you">#</a></h3>
<p>What about faking it ?!</p>
<p>I mean we&rsquo;re developer, we fake a ton of things but can we in this case ? Yes we can !
And the solution is the ultimate tool at faking visual effects <em>SHADER</em>. This time thanks to shaders we&rsquo;ll just fake the drawing of objects meaning that the object will exist in our 2D map but we will show it to the player as some circular world enveloping him.</p>
<p>This solution seems promising, firstly because it&rsquo;s should not be that hard to make, but also because since we fake the drawing of our world we can still work with the basics physics of unity, additionally changing the wrapping parameters should be as easy as moving a slider.</p>
<h2 id="principle">Principle<a hidden class="anchor" aria-hidden="true" href="#principle">#</a></h2>
<p>So how can we bend our object using shader, my idea here is to wrap our 2D map onto a circle.</p>
<p>Let&rsquo;s first make some assumption for our system:</p>
<ul>
<li>
<p>Our world will be build on a plane defined by \(z\) = some constant, so it spans the \(xy\) axis.</p>
</li>
<li>
<p>The \(y\) coordinate will be left untouched, so we can write our coords as \((x, z)\).</p>
</li>
<li>
<p>We will wrap our map around a circle with center \((0, 0)\) and radius \(z\)</p>
</li>
<li>
<p>Our map \(x\) axis will be bound between \([-w, w]\), \(w\) being our map width. The map points with \(x = 0\) won&rsquo;t be moved.</p>
</li>
</ul>
<h3 id="theory">Theory<a hidden class="anchor" aria-hidden="true" href="#theory">#</a></h3>
<p>So from our assumptions let&rsquo;s speak about the math behind it !</p>
<p>The idea is to look at our map from the top, let&rsquo;s call it \(W\), doing so we can see that our world is a line along the \(x\) axis. It is away on the \(z\)-axis by a distance that we will denote \(z\). Here we wish to wrap our map around a circle centered at \((0, 0)\) with a radius \(z\).</p>
<p><img alt="ProblemConstruction" loading="lazy" src="/posts/unity/circular_shader_post/images/ProblemConstruction.gif"></p>
<p>In our case our map is tangent to our circle. The goal is to wrap the world around the cirle so let&rsquo;s first put some reference points. There is no math behind this, this is a design decision I made here so if you want to change it feel free to, you only will need to adapt your formulas to fit your design.</p>
<p><img alt="ExplainPointProjection" loading="lazy" src="/posts/unity/circular_shader_post/images/ExplainPointProjection.gif"></p>
<p>Here we need to find a function to perform such a transformation. We could find many, but let&rsquo;s use the simplest one possible, a linear function.
So in practice that means that if you take a point in between the start and the end of the world and measure its position as percentage of the line crossed, to create the matching point on the circle you would take the start and end of the perimeter and put the point at the previously computed percentage in between both ends.</p>
<p><img alt="ShowMapCircleRelationship" loading="lazy" src="/posts/unity/circular_shader_post/images/ShowMapCircleRelationship.gif"></p>
<p>Since we decided to use a linear function it takes the following form</p>
$$f(x) = ax$$<p>With \(f\) the function which transform the object position on the \(x\) axis to the angle theta of the point in the circular map.</p>
$$f(x) = \theta$$<p>
</p>
$$ax = \theta$$<p>Let&rsquo;s determine \(a\), knowing we want to convert our initial space \([-w, w]\) to \([-\pi, \pi]\). From our design decision we know the following</p>
$$f(0) = 0$$<p>
</p>
$$f(w) = \pi$$<p>For 0 this is obvious \(a \cdot 0 = 0\) it will work for any \(a\), but let&rsquo;s resolve for \(w\)</p>
$$f(w) = \pi$$<p>
</p>
$$a \cdot w = \pi$$<p>
</p>
$$a = \frac{\pi}{w}$$<p>If we plug \(-w\) we notice that it lead to the same value of \(a\).</p>
<p>Now we can rewrite \(f\)</p>
$$f(x) = \frac{\pi}{w} \cdot x \tag{1}$$<p>So once we have the angle we can determine the position in the circle perimeter of our point using some trigonometry, first let&rsquo;s start from the function to express the coordinates \((xc, yc)\) for a circle of radius \(r\) based on \(\theta\)</p>
$$(x_c, y_c) = (sin(\theta), cos(\theta)) \cdot r \tag{2}$$<p>Injecting \((1)\) into \((2)\) we got:</p>
$$(x_c, y_c) = (sin(\frac{\pi}{w} \cdot x), cos(\frac{\pi}{w} \cdot x)) \cdot r$$<p>Now we are able to map the original position \(x\) to the final one \((x_c, y_c)\), let&rsquo;s write the code !</p>
<h2 id="application">Application<a hidden class="anchor" aria-hidden="true" href="#application">#</a></h2>
<p>So here let&rsquo;s do the simplest map possible</p>
<p><img alt="2Dworld" loading="lazy" src="/posts/unity/circular_shader_post/images/bare.png"></p>
<p>Yeah this is bare !</p>
<p>Let&rsquo;s write our shader, first the properties.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>Properties
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _MainTex (<span style="color:#e6db74">&#34;Texture&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    _Tint (<span style="color:#e6db74">&#34;Tint&#34;</span>, Color) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    _GameWidth (<span style="color:#e6db74">&#34;Game width&#34;</span>, Float) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have the properties let&rsquo;s setup the input data and output data of our pass and define the variable we might need.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#75715e">// We define the constant pi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PI 3.14159265359</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The input of our vertex shader</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> appdata
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> POSITION;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The data passed from our vertex shader to our fragment shader</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> v2f
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> SV_POSITION;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We fetch our properties</span>
</span></span><span style="display:flex;"><span>sampler2D _MainTex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> _MainTex_ST;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> _GameWidth;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> _Tint;
</span></span></code></pre></div><p>It was quite simple, we just get the vertex and uv as inputs, we can modify them however we want and we pass them to the fragment shader.</p>
<p>Let&rsquo;s first write the fragment shader since it will be simple</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>fixed4 frag (v2f i) <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_Target</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// sample the texture</span>
</span></span><span style="display:flex;"><span>    fixed4 col <span style="color:#f92672">=</span> tex2D(_MainTex, i.uv) <span style="color:#f92672">*</span> _Tint;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> col;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So basically we just get the color from our texture and mix it with our tint and apply it to the pixel.</p>
<p>So for our most interesting part, we can write our vertex pass ! We just need to write down the formula that we built previously.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>v2f vert (appdata v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the position of the vertex in the world space</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> worldSpaceVertex <span style="color:#f92672">=</span> mul(unity_ObjectToWorld, v.vertex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the relative position of the vertex in the game window</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> percent <span style="color:#f92672">=</span> worldSpaceVertex.x <span style="color:#f92672">/</span> (_GameWidth <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the matching angle associated to the vertex position</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> theta <span style="color:#f92672">=</span> percent <span style="color:#f92672">*</span> PI ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Store the radius</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> radius <span style="color:#f92672">=</span> worldSpaceVertex.z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the circular coordinate</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float2</span> circularCoord <span style="color:#f92672">=</span> <span style="color:#66d9ef">float2</span>(sin(theta), cos(theta)) <span style="color:#f92672">*</span> radius;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Set the new vertex coordinate</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float4</span> newWorldVertex <span style="color:#f92672">=</span> <span style="color:#66d9ef">float4</span>(circularCoord.x, worldSpaceVertex.y, circularCoord.y, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Project the vertex to the clip space</span>
</span></span><span style="display:flex;"><span>    o.vertex <span style="color:#f92672">=</span> mul(UNITY_MATRIX_VP, newWorldVertex);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Set the uv of the vertex</span>
</span></span><span style="display:flex;"><span>    o.uv <span style="color:#f92672">=</span> TRANSFORM_TEX(v.uv, _MainTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Pass the data to the fragment shader</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And that should be it !</p>
<p><img alt="Wtf" loading="lazy" src="/posts/unity/circular_shader_post/images/notbending.png"></p>
<p>Arf we could not call that bending, let&rsquo;s look at the objects wireframes</p>
<p><img alt="WireframeWorld" loading="lazy" src="/posts/unity/circular_shader_post/images/notbendingwireframe.png"></p>
<p>It make sense we only change the positions of the vertex so if you only have that little vertex you cannot really bend it. Let&rsquo;s add more details to our cube.</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/make_cube.mp4" type="video/mp4">
  <span>Your browser doesn't support embedded videos, but don't worry, you can <a href="/posts/unity/circular_shader_post/videos/make_cube.mp4">download it</a> and watch it with your favorite video player!</span>
</video>
<p>Ok now have our cube, let&rsquo;s bend it !</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/bug.mp4" type="video/mp4">
  <span>Your browser doesn't support embedded videos, but don't worry, you can <a href="/posts/unity/circular_shader_post/videos/bug.mp4">download it</a> and watch it with your favorite video player!</span>
</video>
<p>Yes we&rsquo;re g&hellip; good, are we ? Something strange is happening when I&rsquo;m looking on the side</p>
<p>The objects disappear, that&rsquo;s because Unity will cull objects when their bounding boxes don&rsquo;t appear in screens, we did change the vertex positions but not the bounding boxes. Luckily it&rsquo;s quite easy to do it, but this time we
need to write some C# scripts.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoundingBoxUpdater</span> : MonoBehaviour
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Start is called before the first frame update</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Material mat;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> Start()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if the object got a renderer and a material, if not we exit</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> renderer = GetComponent&lt;Renderer&gt;();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (renderer == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> mat = renderer.sharedMaterial;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mat == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check that the material is our wrap shader</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mat.shader.name != <span style="color:#e6db74">&#34;Unlit/WrapShader&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Update the render box by making it huge</span>
</span></span><span style="display:flex;"><span>        renderer.bounds = <span style="color:#66d9ef">new</span> Bounds(newCenter, Vector3.one * <span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ok, Does it work now ?</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/working.mp4" type="video/mp4">
  <span>Your browser doesn't support embedded videos, but don't worry, you can <a href="/posts/unity/circular_shader_post/videos/working.mp4">download it</a> and watch it with your favorite video player!</span>
</video>
<p>Yes, this time we got it ! Just be careful about this solution to change the bounding box. Here we just make it huge so it can be drawn from anywhere but it have performance implications, my advice would be to properly compute bounding boxes based on the new edges positions of the target shape.</p>
<p>Ok last things let&rsquo;s update this shader so it works in VR !</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> appdata
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> v2f
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    UNITY_VERTEX_OUTPUT_STEREO
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>v2f vert (appdata v)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v2f o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    UNITY_SETUP_INSTANCE_ID(v); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>    UNITY_INITIALIZE_OUTPUT(v2f, o); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); <span style="color:#75715e">//Insert</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So for a little VR test, I setup a stupidly simple scene with a character than can move and jump</p>
<video controls preload="auto" width="100%"  playsinline class="html-video">
    <source src="/posts/unity/circular_shader_post/videos/demo.mp4" type="video/mp4">
  <span>Your browser doesn't support embedded videos, but don't worry, you can <a href="/posts/unity/circular_shader_post/videos/demo.mp4">download it</a> and watch it with your favorite video player!</span>
</video>
<p>As we can see we can start from our 2D plateformer to a circular plateformer ! And the physics work as intended because in reality we&rsquo;re still playing a 2D game.</p>
<p>Just let&rsquo;s be careful since our objects can go out of screen we can still see them since our formula follow a sinusoidal pattern.
However the objects will physically be out of the scene, to go further we could either implement some scrolling in our world, or reset the position of the character when we reach the limit, all this is up to your game !</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>The solution is quite satisfying however there are some concerns to take into account</p>
<ul>
<li>
<p>First the solution have a computation cost since you will remap each vertex each frame, even though it should be bearable it still need to be taken into account and it should be properly benchmarked.</p>
</li>
<li>
<p>Objects can get deformed based on the circle / world map ratio so you need to careful set it up and thoroughly think about the way you design your assets, it might also be possible to pick a different projection formula to mitigate these effects.</p>
</li>
<li>
<p>You might need to write some tooling to help your designer work in this new environment.</p>
</li>
</ul>
<p>However I think there are a ton of possibilites and I believe it can make VR game damn fun, I&rsquo;d love to see some game using this principle in VR !
I might try to experiment more with it and maybe make something playable, tell me what you think about it.</p>
<p>Also here the source for anyone who desire to play with it <a href="https://github.com/sammedhi/WrapShader">here</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://sammedhi.github.io/">Impyou&#39;s voyage</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
